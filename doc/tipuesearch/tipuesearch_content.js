var tipuesearch = {"pages":[{"text":"This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. PolyCon Provides an abstract container derived type which can be used \nas a sort of unlimited polymorphic entity whose contents are\nretrievable with type-guards. Different subclasses are created\nin order to hold different data-types. Subclasses are provided for\nthe default variable types in Fortran. The abstract type can be used\nwithin data structures to so that a single implementation can hold\narbitrary types of contents. The type of the contents can be selected\nwhen the data structure is constructed, by passing a particular subclass\nof the abstract container to the constructor. At present the single greatest weakness of this project is that it does\nnot support the storage of arrays--only scalars (although scalar coarrays\nshould be fine). It is unclear whether or not a solution to this problem\nis readily available. Extensions to the abstract type must implement the procedure typeguard , which tests that variables being passed to the\ncontainer or to which the container's contents are assigned are of the\ncorrect type. An example of a concrete implementation to hold a user-defined\nderived type is provided below. module example_container_mod use abstract_container_mod implicit none private type example integer , public :: i end type example type , extends ( container_type ) :: example_container contains private procedure :: typeguard => example_guard end type example_container contains logical function example_guard ( this , lhs ) result ( ret ) class ( example_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( example ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function example_guard end module example_container_mod Compiling PolyCon is known to work with Gfortran 5.3.0 and ifort 16.0.1 on Ubuntu/Linux\nMint. It is known not to work for storing character strings when using\nGfortran 4.8. The latter\nrequires the -assume realloc_lhs to be used. A makefile is provided which\ncalls gfortran-5 . Static and shared libraries are compiled using make static and make shared , respectively. The test program can be build using make test . At present there is no facility to install the libraries on your\nsystem. Documentation In addition to the documentation in the README, the API is documented\nusing FORD . This documentation can\nbe found in the ./doc directory in the repository. License This code is licensed under the GPLv3. More permissive licensing may be\nconsidered in future. Developer Info Chris MacMackin I am a graduate student at the University of Oxford, studying the melting and evolution of ice shelves. I enjoy programming, with my favourite languages being Fortran (for numerical work), Vala (for object-oriented programming and anything involving a GUI), and Python (for scripting and everything else).","tags":"","loc":"index.html","title":" This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"Source Code !  container_mod.f90 ! !  Copyright 2015 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! ! module container_mod !! Author: Chris MacMackin !! Date: December 2015 !! License: GPLv3 !! !! Provides implementations of the [[container_type]] abstract !! derived type for all of the built-in variable types. use abstract_container_mod , only : container_type use iso_fortran_env , only : i1 => int8 , i2 => int16 , i4 => int32 , & i8 => int64 , r4 => real32 , r8 => real64 , & r16 => real128 implicit none private type , extends ( container_type ) :: int_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt integer type. contains private procedure :: typeguard => int_guard end type int_container type , extends ( container_type ) :: int1_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 1 byte integer type. contains private procedure :: typeguard => int1_guard end type int1_container type , extends ( container_type ) :: int2_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 2 byte integer type. contains private procedure :: typeguard => int2_guard end type int2_container type , extends ( container_type ) :: int4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte integer type. contains private procedure :: typeguard => int4_guard end type int4_container type , extends ( container_type ) :: int8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte integer type. contains private procedure :: typeguard => int8_guard end type int8_container type , extends ( container_type ) :: real_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt real type. contains private procedure :: typeguard => real_guard end type real_container type , extends ( container_type ) :: real4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte real type. contains private procedure :: typeguard => real4_guard end type real4_container type , extends ( container_type ) :: real8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte real type. contains private procedure :: typeguard => real8_guard end type real8_container type , extends ( container_type ) :: real16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte real type. contains private procedure :: typeguard => real16_guard end type real16_container type , extends ( container_type ) :: complex_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt complex type. contains private procedure :: typeguard => complex_guard end type complex_container type , extends ( container_type ) :: complex4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte complex type. contains private procedure :: typeguard => complex4_guard end type complex4_container type , extends ( container_type ) :: complex8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte complex type. contains private procedure :: typeguard => complex8_guard end type complex8_container type , extends ( container_type ) :: complex16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte complex type. contains private procedure :: typeguard => complex16_guard end type complex16_container type , extends ( container_type ) :: logical_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt logical type. contains private procedure :: typeguard => logical_guard end type logical_container type , extends ( container_type ) :: character_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt character type. contains private procedure :: typeguard => character_guard end type character_container public :: character_container , complex_container , complex4_container , & complex8_container , complex16_container , int_container , & int1_container , int2_container , int4_container , & int8_container , logical_container , real_container , & real4_container , real8_container , real16_container contains logical function int_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int_guard logical function int1_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int1_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i1 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int1_guard logical function int2_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int2_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i2 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int2_guard logical function int4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int4_guard logical function int8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int8_guard logical function real_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real_guard logical function real4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real4_guard logical function real8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real8_guard logical function real16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real16_guard logical function complex_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex_guard logical function complex4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex4_guard logical function complex8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex8_guard logical function complex16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex16_guard logical function logical_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( logical_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( logical ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function logical_guard logical function character_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( character_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( character ( len =* )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function character_guard end module container_mod","tags":"","loc":"sourcefile/container_mod.f90.html","title":"container_mod.f90 – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types."},{"text":"Source Code !  abstract_container_mod.f90 ! !  Copyright 2015 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! ! module abstract_container_mod !! Author: Chris MacMackin !! Date: December 2015 !! License: GPLv3 !! !! Provides an abstract container derived type which can be used !! as a sort of unlimited polymorphic entity whose contents are !! retrievable with type-guards. Different subclasses are created !! in order to hold different data-types. See [[container_type]] for !! instructions on creating concrete subclasses. See [[container_mod]] !! for subclasses containing the built-in data-types. use iso_fortran_env , only : stderr => error_unit implicit none private type , abstract :: container_type !! Author: Chris MacMackin !! Date: December 2015 !! Display: Public !!          Private !! !! An abstract derived type which contains data. This type can be !! used for a sort of unlimited polymorphism. It is extended to !! create different classes capable of holding particular !! data-types. Extensions must implement the procedure !! [[container_type:typeguard]] in order to provide the ability to !! transfer data out of the container and into a variable. Assuming !! that you are creating a concrete class called !! `example_container`, this should be implemented as follows: !! !!```fortran !! module example_container_mod !! !!   use abstract_container_mod !!   implicit none !!   private !! !!   type example !!     integer, public :: i !!   end type example !! !!   type, extends(container_type) :: example_container !!   contains !!     private !!     procedure :: typeguard => example_guard !!   end type example_container !! !! contains !! !!   logical function example_guard(this, lhs) result(ret) !!     class(example_container), intent(in) :: this !!     class(*), intent(inout) :: lhs !!     select type(lhs) !!       type is(example) !!         lhs = transfer(this%contents(), lhs) !!         ret = .true. !!       class default !!         ret = .false. !!     end select !!   end function example_guard !! !! end module example_container_mod !!``` private character ( len = 1 ), dimension (:), allocatable :: storage !! Variable in which to place data contents logical :: filled = . false . !! `.true.` if container is set, `.false.` otherwise contains private procedure ( guard ), deferred :: typeguard !! Performs the actual transfer of the container's contents to !! another variable. procedure , public :: contents !! Retrieves the contents of the container, in the form of a !! character array. procedure , public :: set !! Sets the contents of the container. procedure , pass ( rhs ) :: assign_container !! Assigns container contents to another variable. generic , public :: assignment ( = ) => assign_container end type container_type abstract interface logical function guard ( this , lhs ) import container_type class ( container_type ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs !! The variable which the container contents are to be !! transferred to. end function guard end interface public :: container_type contains subroutine assign_container ( lhs , rhs ) !! Transfers the contents of the container to another variable. !! If the other variable is another container of the same type !! then the contents will be transferred. If the other variable is !! the same type as the contents of the container (as determined !! by the [[container_type:typeguard]] routine provided for that !! concrete type extension) then it will be given the value held by !! the container. Otherwise, an error message will be printed and !! the program stopped. If compiled with `gfortran` then a backtrace !! will also be printed. In the event that the container was never !! set to a value, then this also constitutes an error. class ( * ), intent ( inout ) :: lhs !! The variable which the container contents will be assigned to. class ( container_type ), intent ( in ) :: rhs !! The container variable. !------------------------------------------------------------------- select type ( lhs ) class is ( container_type ) if ( same_type_as ( lhs , rhs )) then lhs % storage = rhs % storage return else write ( stderr , * ) \"ERROR: Can not assign to a different container subclass\" #ifdef __GFORTRAN__ call backtrace #endif stop end if class default if ( rhs % filled ) then if ( rhs % typeguard ( lhs )) return write ( stderr , * ) \"ERROR: Can not assign this container's contents to given variable\" #ifdef __GFORTRAN__ call backtrace #endif stop else write ( stderr , * ) \"ERROR: Container is empty.\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end select end subroutine assign_container pure function contents ( this ) !! Returns the contents, encoded as a character array, of the !! container. class ( container_type ), intent ( in ) :: this character ( len = 1 ), dimension (:), allocatable :: contents contents = this % storage end function contents subroutine set ( this , content ) !! Sets the contents of the array to value passed. The type of the !! variable provided must be the same as the container variable is !! designed to accept (as determined by the implementation of the !! [[container_type:typeguard]] method in the concrete type !! extension), or else an error message will be printed and the !! program will exit. If `gfortran` was used to compile then a !! backtrace will also be printed. class ( container_type ), intent ( out ) :: this class ( * ), intent ( in ) :: content !! The value to be placed in the container class ( * ), allocatable :: tmp allocate ( tmp , source = content ) if (. not . allocated ( this % storage )) allocate ( this % storage ( 1 )) if ( this % typeguard ( tmp )) then this % filled = . true . this % storage = transfer ( content , this % storage ) else write ( stderr , * ) \"ERROR: Can not assign given variable to this container\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end subroutine set end module abstract_container_mod","tags":"","loc":"sourcefile/abstract_container_mod.f90.html","title":"abstract_container_mod.F90 – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types."},{"text":"Source Code !  container_test.f90 ! !  Copyright 2015 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! ! program container_test !! Author: Chris MacMackin !! Date: December 2015 !! License: GPLv3 !! !! A test suite for the various concrete implementations of the !! [[container_type]]. These implementations can be found int !! [[container_mod]] and are for all of the default scalar data types. use container_mod use abstract_container_mod use iso_fortran_env , only : i1 => int8 , i2 => int16 , i4 => int32 , & i8 => int64 , r4 => real32 , r8 => real64 , & r16 => real128 implicit none ! container types to test type ( character_container ) :: char_c type ( complex_container ) :: comp_c type ( complex4_container ) :: comp4_c type ( complex8_container ) :: comp8_c type ( complex16_container ) :: comp16_c type ( int_container ) :: int_c type ( int1_container ) :: int1_c type ( int2_container ) :: int2_c type ( int4_container ) :: int4_c type ( int8_container ) :: int8_c type ( logical_container ) :: log_c type ( real_container ) :: real_c type ( real4_container ) :: real4_c type ( real8_container ) :: real8_c type ( real16_container ) :: real16_c ! variables in which to store input/output from containers character ( len = 12 ) :: charin = 'Hello world!' , charout = '' complex :: compin = ( 1.0 , 2.0 ), compout = ( 0.0 , 0.0 ) complex ( r4 ) :: comp4in = ( 1.0_r4 , 2.0_r4 ), comp4out = ( 0.0_r4 , 0.0_r4 ) complex ( r8 ) :: comp8in = ( 1.0_r8 , 2.0_r8 ), comp8out = ( 0.0_r8 , 0.0_r8 ) complex ( r16 ) :: comp16in = ( 1.0_r16 , 2.0_r16 ), comp16out = ( 0.0_r16 , 0.0_r16 ) logical :: login = . true ., logout = . false . integer :: intin = 1 , intout = 0 integer ( i1 ) :: int1in = 1_i1 , int1out = 0_i1 integer ( i2 ) :: int2in = 1_i2 , int2out = 0_i2 integer ( i4 ) :: int4in = 1_i4 , int4out = 0_i4 integer ( i8 ) :: int8in = 1_i8 , int8out = 0_i8 real :: realin = 1.0 , realout = 0.0 real ( r4 ) :: real4in = 1.0_r4 , real4out = 0.0_r4 real ( r8 ) :: real8in = 1.0_r8 , real8out = 0.0_r8 real ( r16 ) :: real16in = 1.0_r16 , real16out = 0.0_r16 call perform_test ( char_c , charin , charout , 'character_container' ) call perform_test ( comp_c , compin , compout , 'complex_container' ) call perform_test ( comp4_c , comp4in , comp4out , 'complex4_container' ) call perform_test ( comp8_c , comp8in , comp8out , 'complex8_container' ) call perform_test ( comp16_c , comp16in , comp16out , 'complex16_container' ) call perform_test ( log_c , login , logout , 'logical_container' ) call perform_test ( int_c , intin , intout , 'int_container' ) call perform_test ( int1_c , int1in , int1out , 'int1_container' ) call perform_test ( int2_c , int2in , int2out , 'int2_container' ) call perform_test ( int4_c , int4in , int4out , 'int4_container' ) call perform_test ( int8_c , int8in , int8out , 'int8_container' ) call perform_test ( real_c , realin , realout , 'real_container' ) call perform_test ( real4_c , real4in , real4out , 'real4_container' ) call perform_test ( real8_c , real8in , real8out , 'real8_container' ) call perform_test ( real16_c , real16in , real16out , 'real16_container' ) contains subroutine perform_test ( container , inval , outval , cont_name ) !! Performs the actual test on the containers. Also is effectively !! testing that the polymorphism of [[container_type]] is behaving !! as desired. class ( container_type ), intent ( inout ) :: container !! The particular container which is to be tested class ( * ), intent ( in ) :: inval !! The value to place into the container class ( * ), intent ( inout ) :: outval !! A variable in which to place the container's contents character ( len =* ), intent ( in ) :: cont_name !! The name of the container class, to be used when printing output character , dimension ( 1 ) :: mold character ( len = 30 ), parameter :: header_form = '(\"Running test on \", a, \"...\")' character ( len = 39 ), parameter :: set_form = '(\"Setting container to input value...\")' character ( len = 44 ), parameter :: get_form = '(\"Retreiving value from container...\")' character ( len = 31 ), parameter :: result_form = '(\"Test of \", a, \" \", a, \".\", /)' write ( * , header_form ) cont_name write ( * , set_form ) call container % set ( inval ) write ( * , get_form ) outval = container if ( all ( transfer ( outval , mold ) == transfer ( inval , mold ))) then write ( * , result_form ) cont_name , 'PASSED' else write ( * , result_form ) cont_name , 'FAILED' end if end subroutine perform_test end program container_test","tags":"","loc":"sourcefile/container_test.f90.html","title":"container_test.f90 – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types."},{"text":"type, public, extends(container_type) :: int_container A container for holding the defualt integer type.","tags":"","loc":"type/int_container.html","title":"int_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: int1_container A container for holding the 1 byte integer type.","tags":"","loc":"type/int1_container.html","title":"int1_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: int2_container A container for holding the 2 byte integer type.","tags":"","loc":"type/int2_container.html","title":"int2_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: int4_container A container for holding the 4 byte integer type.","tags":"","loc":"type/int4_container.html","title":"int4_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: int8_container A container for holding the 8 byte integer type.","tags":"","loc":"type/int8_container.html","title":"int8_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: real_container A container for holding the defualt real type.","tags":"","loc":"type/real_container.html","title":"real_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: real4_container A container for holding the 4 byte real type.","tags":"","loc":"type/real4_container.html","title":"real4_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: real8_container A container for holding the 8 byte real type.","tags":"","loc":"type/real8_container.html","title":"real8_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: real16_container A container for holding the 16 byte real type.","tags":"","loc":"type/real16_container.html","title":"real16_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: complex_container A container for holding the defualt complex type.","tags":"","loc":"type/complex_container.html","title":"complex_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: complex4_container A container for holding the 4 byte complex type.","tags":"","loc":"type/complex4_container.html","title":"complex4_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: complex8_container A container for holding the 8 byte complex type.","tags":"","loc":"type/complex8_container.html","title":"complex8_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: complex16_container A container for holding the 16 byte complex type.","tags":"","loc":"type/complex16_container.html","title":"complex16_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: logical_container A container for holding the defualt logical type.","tags":"","loc":"type/logical_container.html","title":"logical_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, extends(container_type) :: character_container A container for holding the defualt character type.","tags":"","loc":"type/character_container.html","title":"character_container – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"type, public, abstract :: container_type An abstract derived type which contains data. This type can be\n used for a sort of unlimited polymorphism. It is extended to\n create different classes capable of holding particular \n data-types. Extensions must implement the procedure typeguard in order to provide the ability to\n transfer data out of the container and into a variable. Assuming\n that you are creating a concrete class called example_container , this should be implemented as follows: module example_container_mod use abstract_container_mod implicit none private type example integer , public :: i end type example type , extends ( container_type ) :: example_container contains private procedure :: typeguard => example_guard end type example_container contains logical function example_guard ( this , lhs ) result ( ret ) class ( example_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( example ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function example_guard end module example_container_mod Components Type Visibility Attributes Name Initial character(len=1), private, dimension(:), allocatable :: storage Variable in which to place data contents logical, private :: filled = .false. .true. if container is set, .false. otherwise Type-Bound Procedures procedure(guard), private, deferred :: typeguard Performs the actual transfer of the container's contents to \n another variable. function guard (this, lhs) Prototype Arguments Type Intent Optional Attributes Name class( container_type ), intent(in) :: this class(*), intent(inout) :: lhs The variable which the container contents are to be \n transferred to. Return Value logical procedure, public :: contents Retrieves the contents of the container, in the form of a\n character array. private pure function contents(this) Arguments Type Intent Optional Attributes Name class( container_type ), intent(in) :: this Return Value character(len=1),\n  dimension(:),allocatable Description Returns the contents, encoded as a character array, of the \n container. procedure, public :: set Sets the contents of the container. private subroutine set(this, content) Arguments Type Intent Optional Attributes Name class( container_type ), intent(out) :: this class(*), intent(in) :: content The value to be placed in the container Description Sets the contents of the array to value passed. The type of the \n variable provided must be the same as the container variable is\n designed to accept (as determined by the implementation of the typeguard method in the concrete type \n extension), or else an error message will be printed and the\n program will exit. If gfortran was used to compile then a \n backtrace will also be printed. procedure, private, pass(rhs) :: assign_container Assigns container contents to another variable. private subroutine assign_container(lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container_type ), intent(in) :: rhs The container variable. Description Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. generic, public :: assignment(=) => assign_container private subroutine assign_container(lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container_type ), intent(in) :: rhs The container variable. Description Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error.","tags":"","loc":"type/container_type.html","title":"container_type – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types. "},{"text":"subroutine perform_test(container, inval, outval, cont_name) Arguments Type Intent Optional Attributes Name class( container_type ), intent(inout) :: container The particular container which is to be tested class(*), intent(in) :: inval The value to place into the container class(*), intent(inout) :: outval A variable in which to place the container's contents character(len=*), intent(in) :: cont_name The name of the container class, to be used when printing output Description Performs the actual test on the containers. Also is effectively\n testing that the polymorphism of container_type is behaving\n as desired. Variables Type Visibility Attributes Name Initial character, public, dimension(1) :: mold character(len=30), public, parameter :: header_form = '(\"Running test on \", a, \"...\")' character(len=39), public, parameter :: set_form = '(\"Setting container to input value...\")' character(len=44), public, parameter :: get_form = '(\"Retreiving value from container...\")' character(len=31), public, parameter :: result_form = '(\"Test of \", a, \" \", a, \".\", /)'","tags":"","loc":"proc/perform_test.html","title":"perform_test – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types."},{"text":"Uses: abstract_container_mod iso_fortran_env Provides implementations of the container_type abstract\n derived type for all of the built-in variable types. Derived Types type, public, extends(container_type) :: int_container Description A container for holding the defualt integer type. type, public, extends(container_type) :: int1_container Description A container for holding the 1 byte integer type. type, public, extends(container_type) :: int2_container Description A container for holding the 2 byte integer type. type, public, extends(container_type) :: int4_container Description A container for holding the 4 byte integer type. type, public, extends(container_type) :: int8_container Description A container for holding the 8 byte integer type. type, public, extends(container_type) :: real_container Description A container for holding the defualt real type. type, public, extends(container_type) :: real4_container Description A container for holding the 4 byte real type. type, public, extends(container_type) :: real8_container Description A container for holding the 8 byte real type. type, public, extends(container_type) :: real16_container Description A container for holding the 16 byte real type. type, public, extends(container_type) :: complex_container Description A container for holding the defualt complex type. type, public, extends(container_type) :: complex4_container Description A container for holding the 4 byte complex type. type, public, extends(container_type) :: complex8_container Description A container for holding the 8 byte complex type. type, public, extends(container_type) :: complex16_container Description A container for holding the 16 byte complex type. type, public, extends(container_type) :: logical_container Description A container for holding the defualt logical type. type, public, extends(container_type) :: character_container Description A container for holding the defualt character type.","tags":"","loc":"module/container_mod.html","title":"container_mod – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types."},{"text":"Uses: iso_fortran_env Provides an abstract container derived type which can be used \n as a sort of unlimited polymorphic entity whose contents are\n retrievable with type-guards. Different subclasses are created\n in order to hold different data-types. See container_type for \n instructions on creating concrete subclasses. See container_mod for subclasses containing the built-in data-types. Derived Types type, public, abstract :: container_type Components Type Visibility Attributes Name Initial character(len=1), private, dimension(:), allocatable :: storage Variable in which to place data contents logical, private :: filled = .false. .true. if container is set, .false. otherwise Type-Bound Procedures procedure(guard), private, deferred :: typeguard Performs the actual transfer of the container's contents to \n another variable. procedure, public :: contents Retrieves the contents of the container, in the form of a\n character array. procedure, public :: set Sets the contents of the container. procedure, private, pass(rhs) :: assign_container Assigns container contents to another variable. generic, public :: assignment(=) => assign_container Description An abstract derived type which contains data. This type can be\n used for a sort of unlimited polymorphism. It is extended to\n create different classes capable of holding particular \n data-types. Extensions must implement the procedure typeguard in order to provide the ability to\n transfer data out of the container and into a variable. Assuming\n that you are creating a concrete class called example_container , this should be implemented as follows:","tags":"","loc":"module/abstract_container_mod.html","title":"abstract_container_mod – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types."},{"text":"Uses: container_mod abstract_container_mod iso_fortran_env A test suite for the various concrete implementations of the container_type . These implementations can be found int container_mod and are for all of the default scalar data types. Variables Type Attributes Name Initial type( character_container ) :: char_c type( complex_container ) :: comp_c type( complex4_container ) :: comp4_c type( complex8_container ) :: comp8_c type( complex16_container ) :: comp16_c type( int_container ) :: int_c type( int1_container ) :: int1_c type( int2_container ) :: int2_c type( int4_container ) :: int4_c type( int8_container ) :: int8_c type( logical_container ) :: log_c type( real_container ) :: real_c type( real4_container ) :: real4_c type( real8_container ) :: real8_c type( real16_container ) :: real16_c character(len=12) :: charin = 'Hello world!' character(len=12) :: charout = '' complex :: compin = (1.0,2.0) complex :: compout = (0.0,0.0) complex(kind=r4) :: comp4in = (1.0_r4,2.0_r4) complex(kind=r4) :: comp4out = (0.0_r4,0.0_r4) complex(kind=r8) :: comp8in = (1.0_r8,2.0_r8) complex(kind=r8) :: comp8out = (0.0_r8,0.0_r8) complex(kind=r16) :: comp16in = (1.0_r16,2.0_r16) complex(kind=r16) :: comp16out = (0.0_r16,0.0_r16) logical :: login = .true. logical :: logout = .false. integer :: intin = 1 integer :: intout = 0 integer(kind=i1) :: int1in = 1_i1 integer(kind=i1) :: int1out = 0_i1 integer(kind=i2) :: int2in = 1_i2 integer(kind=i2) :: int2out = 0_i2 integer(kind=i4) :: int4in = 1_i4 integer(kind=i4) :: int4out = 0_i4 integer(kind=i8) :: int8in = 1_i8 integer(kind=i8) :: int8out = 0_i8 real :: realin = 1.0 real :: realout = 0.0 real(kind=r4) :: real4in = 1.0_r4 real(kind=r4) :: real4out = 0.0_r4 real(kind=r8) :: real8in = 1.0_r8 real(kind=r8) :: real8out = 0.0_r8 real(kind=r16) :: real16in = 1.0_r16 real(kind=r16) :: real16out = 0.0_r16 Subroutines subroutine perform_test (container, inval, outval, cont_name) Arguments Type Intent Optional Attributes Name class( container_type ), intent(inout) :: container The particular container which is to be tested class(*), intent(in) :: inval The value to place into the container class(*), intent(inout) :: outval A variable in which to place the container's contents character(len=*), intent(in) :: cont_name The name of the container class, to be used when printing output Description Performs the actual test on the containers. Also is effectively\n testing that the polymorphism of container_type is behaving\n as desired.","tags":"","loc":"program/container_test.html","title":"container_test – This provides an abstract data type, for which subclasses can be created to hold any type of variable as contents. Subclasses are provided for all of the built in variable types."}]}